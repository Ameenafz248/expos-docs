---
title: XSM Virtual Machine Model
original_url: https://exposnitc.github.io/virtual_machine_spec.html
---

### Scope of the Document
 
The Virtual Machine model defines the view of the machine to user mode programs. User mode programs are executed in the unprivileged mode.  Consequently,  the privileged mode instructions cannot be used by them. Their memory view and registers available are also limited.  This restricted model is discussed below.

### Virtual Machine Organisation

The XSM virtual machine model defines the machine model provided by XSM to a program running in **user mode**. This model comprises of a restricted subset of the machine registers, a restricted instruction set and a restricted memory address space (called the **virtual/logical address space**).


#### Registers
The XSM architecture maintains several registers and ports, each capable of storing a number/string, out of which, only some are accessible in unprivileged mode.  The registers available in the unprivileged mode are

| Registers  | Purpose                              |
| ---------- | ------------------------------------ |
| R0-R19     | General purpose program registers    |
| BP, SP, IP | Base, Stack and Instruction Pointers |

#### Virtual (Memory) Address Space

The virtual (or logical) memory addresses that can be generated by a user mode program is determined by the value of the PTLR register. The virtual address space of a user mode program is a contiguous address space starting from 0 to 512\*PTLR-1. The virtual addreses generated by a user mode program are translated into physical addresses by the [address translation scheme](./arch-spec/paging-hardware.md) of XSM. The user mode program is oblivious to the address translation.

Operating systems using the XSM architecture typically specifies the maximum value of PTLR permitted
for its user processes and divide the allocated address space for an application into library, code,
data, stack, heap etc.

<figure>
    <img src="https://exposnitc.github.io/img/addr_transln.png">
</figure>

### Interrupts
Software Interrupts (traps) are the mechanisms by which user mode programs can transfer control to the code that runs in the kernel mode. Software interrupt service routines typically contain the OS code for various system calls. Upon return from a software interrupt, execution resumes from the next instruction in the user mode program. A total of 15 software interrupts are available to a user mode program (Interrupt 4 - Interrupt 18).

### Instruction Set
Every instruction in XSM is two words long.  The unprivileged instructions are categorized into :

??? note "Data Transfer Instructions"
    Family of instructions concerned with moving data between a register and a register/memory location/ integer or string constant. The MOV instruction supports data transfer through various addressing modes.

??? note "Arithmetic Instructions"
    Arithmetic Instructions perform arithmetic operations on registers containing integers. If the register contains a non-integer value, an exception is raised. The arithmetic instructions are ADD, SUB, MUL, DIV, MOD, INR and DCR.

??? note "Logical Instructions"
    Logical instructions are used for comparing values in registers. Strings can also be compared according to the lexicographic ordering of ASCII. Logical instructions are GT, LT, EQ, NE, GE and LE.

??? note "Branching Instructions"
    Branching is achieved by changing the value of the IP to the word address of the target instruction specified by target_address.    
    The branching instructions are JZ, JNZ, JMP

??? note "Stack Instructions"
    The stack instructions are PUSH and POP.

??? note "Subroutine Instructions"
    The subroutine instructions provide a mechanism for procedure invocations. The subroutine instructions are CALL and RET.

??? note "Debug Instructions"
    The machine when run in debug mode invokes the debugger when this instruction is executed. This instruction can be used for debugging system code. The instruction for entering the debug mode is BRKP.

??? note "Software Interrupt"
    Generates an interrupt to the kernel with n (4 to 18) as a parameter. The instruction for triggering interrupt is INT n, where n is the interrupt routine number.

The details of the semantics of these instructions is given in [here](./arch-spec/instruction-set.md)